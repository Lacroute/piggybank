TRIER COMPTE
============

Dictionnaire dépenses, recettes

Pour chaque opération dans compte faire
	dicoTemp = dépenses
	si opération.montant > 0 alors
		dicoTemp = recettes
	fsi
	insérer opération dans dicoTemp avec opération.libellé en clé
fpour

FIN


IDENTIFIER RECURRENCE dicoTrié, fixe, [recurrent]
=====================

	pour chaque groupe dans dicoTrié faire
		si groupe.length > 1 alors
			moyenne = 0
			pour chaque opération dans groupe faire
				moyenne += absolue(opération.montant)
			fpour
			moyenne = moyenne / groupe.length
			seuil = moyenne * tauxTolérance
			estFixe = vrai

			tant que non fin groupe && estFixe faire
				si absolue(moyenne - montant) >= seuil alors
					estFixe = faux
				fsi
			ftant

			si estFixe alors
				insérer opération dans fixe avec libellé en clé
			sinon si recurrent != null
				insérer opération dans récurrent avec libellé en clé
			fsi
		fsi
	fpour

	mise en mémoire de fixe et récurrent

FIN


VERIFICATION ANALYSE USER 
=========================

	récupérer recetteFixes
	pour chaque opération dans recetteFixes faire
		demander si c'est bien un revenu fixe à l'user (UX à définir)
		si réponse == oui alors
			opération.extVérifiée = vrai
		sinon
			supprimer opération de recetteFixes
		fsi
	fpour

	récupérer dépensesFixe et dépensesRécurrentes

	pour chaque opération dans dépenseFixe faire
		demander si c'est bien une dépense fixe
		opération.estVérifiée = vrai
		si réponse == non alors
			insérer opération dans dépensesRécurrentes avec libellé en clé
			supprimer opération de dépenseFixe
		fsi
	fpour

	pour chaque opération dans dépensesRécurrentes faire
		si opération.estVérifiée = faux alors
			demander si c'est une dépense récurrente
			opération.estVérifiée = vrai
			si réponse == non alors
				insérer opération dans dépensesFixes avec libellé en clé
				supprimer opérationde dépensesRécurrentes
			fsi
		fsi
	fpour

	mise en mémoire de recetteFixes, dépensesFixes, dépensesRécurrentes

FIN



DÉFINIR ENVELOPPE QUOTIDIENNE
=============================

	récupérer recettesFixes
	revenuMaximal = recetteFixes[0]
	sommeRevenus = revenuMaximal[0].montant

	pour  i=1 à i=recettesFixes.length, i++ faire
		si recettesFixes[i].montant > revenuMaximal.montant alors
			revenuMaximal = recettesFixes[i]
		sinon si recettesFixes[i].montant == revenuMaximal.montant && recettesFixes[i].date > revenuMaximal.date alors
			revenuMaximal = recettesFixes[i]
		fsi
		sommeRevenus += recettesFixes[i].montant
	fpour

	si solde < 0 alors
		enveloppe = 0
	sinon
		nbjoursrestant = revenuMaximal.date - aujourd'hui
		base = solde - ConstanteMinimum
		si base < 0 alors
			alerte utilisateur t'es dans la merde Morray
			base = solde
		fsi

		enveloppe = sommeRevenus / revenuMaximal.interval
		si base/nbjoursrestant < enveloppe alors
			enveloppe = base / nbjoursrestant
		fsi

		mise en mémoire de enveloppe
	fsi

FIN


MONTHLY PROPORTIONAL timestamp1, timestamp2
===================

	result = false
	interval = abs(timestamp1 - timestamp2)
	if interval <= TIME_FLEXIBILITY && getMonth(timestamp1) != getMonth(timestamp2) then
		result = true
	endif

	return result

END


IDENTIFY RECURRENT
====================

	1st : group by alias
	2nd : keep only same amount +/- AMOUNT_FLEXIBILITY -> return operationGroupByAliasAmount (gbaa)

	// Check recurrency

	j = 0
	gbaaLength = gbaa.length
	for(i=0 to i<gbaaLength , i++){
		j = i + 1
		regular = true
		
		while regular && j<gbaaLength-1 {
			regular = monthlyProportional(gbaa[i], gbaa[j])
			j++
		}

		// If it's not the penultimate
		if(!regular && j < gbaaLength-2){
			move gbaa[i] from gbaa to general debit
		}
	}

	if(j == gbaaLength-2){
		// Réfléchir à comment traiter ce cas
	}


END


DEFINE NEXT ENVELOPE
===============
	// Le but : arriver à rester au dessus d'un solde défini (FIXED_BALANCE par défaut = 0) tout au long du mois
	//  Comment : identifier le prochain salaire, chercher toutes les dépenses fixes connue jusque là, les soustraires, chercher toutes les entrées d'arganet jusque là, les ajouter, obtenir le solde future le soustraire au FIXED_BALANCE. On obtient l'enveloppe. On la divise par le nombre de jour jusqu'à ce salaire.


	// Récupérer le solde
	account_balance = account.getBalance()

	fixed_debit = account.getFixedDebit()
	fixed_credit = account.getFixedCredit()

	// Récupérer le revenu fixe maximum (penser à le stocker quelquepart pour éviter les boucles inutiles)
	// max_income est un tableau contenant toutes les opération du lébellé ayant la somme la plus importante
	max_income = fixed_credit[0][0]
	for(i=1; i<fixed_credit; i++){
		if(max_income.amount < fixed_credit[i][0].amount){
			max_income = fixed_credit[i]
		}
	}


	// identifier les revenus qui vont arriver dans le mois
	debut = max_income[0].date
	fin = max_income[0].date
	sum_monthly_credit = 0
	for(i=0; i<fixed_credit.length; i++){
		if(debut <= fixed_credit[i][0].date && fixed_credit[i][0].date < fin){
			sum_monthly_credit += fixed_credit[i][0].amount
		}
	}


	// Identifier les dépenses qui vont avoir lieu dans le mois ==> en faiire une fonction de type getSumMonthly
	sum_monthly_debit = 0
	for(i=0; i<fixed_debit.length; i++){
		if(debut <= fixed_debit[i][0].date && fixed_debit[i][0].date < fin){
			sum_monthly_debit += fixed_debit[i][0].amount
		}
	}


	monthly_envelope = sum_monthly_debit - sum_monthly_credit

	// tester et prévenir si c'est la merde > mettre dans une fonction isItPlausible()
	if(monthly_envelope < FIXED_BALANCE){
		alert("T'arriveras pas à garder ton solde Morray, baisse ton objectif !")
	}
	// MINIMAL_ENVELOPE est une constante égale à un pourcentage du revenu (ex: 10%)
	if(monthly_envelope < MINIMAL_ENVELOPE){
		alerte("Ca va etre très dur Morray, baisse ton objectif ou mange des pates")
	}
	if(monthly_envelope < 0){
		alerte("c'est vraiment la merde Morray !")
	}


	daily_envelope_reference = monthly_envelope / (fin - debut)
	daily_envelope_real = daily_envelope_reference * (fin - aujourd'hui)


